--------------- 2023 - 03 - 07 ------------------
		온라인 게임서버 환경

MMO 게임 서버 특 	- 고사양 pc로 동접 늘림, 가성비 저사양 pc 여러대 X -> 웹서버나 MO게임은 가능함 
		- 가능한 최고 사양의 pc를 사용

고사양 PC 	- Single core로는 동접 1000도 어려움
			-Multicore 사용, MultiThread 필요

게임서버 하드웨어	- HW를 100%를 활용할 수 있는 프로그래밍이 필요
			-멀티 Core, CPU, 네트워크 프로그래밍
	CPU	- 서버용 CPU가 따로 존재
			ex) Intel Xeon, AMD EPYC -> 고성능이고 더럽게 비쌈
						 -> 특수한 기능 존재
		- 64bit, Multi-Core 필요
		- 코어 개수, 클럭속도와 Cache 크기, 메모리 Bus대역폭도 중요하다	
			-EPYC은 클럭속도는 일반 CPU보다 느리지만 나머지가 압도적으로 좋음

	서버 CPU	- 서버용 CPU는 Multi Processor 지원
			- Cache 동기화 지원
				- A CPU에서 데이터를 바꾼것을 B CPU에서도 반영 (Xeon)
		- 서버용 CPU는 서로간의 데이터 전송 전용 통로를 제공
			- AMD(2001s~) 30~512GB/s, Intel(2009s~) 6TB/s
			- 이것은 존재 여부에 때라 동접이 10배이상 차이남 (교수님 NC 썰)
		- 메모리 채널 증가 : 8개 까지

64비트 이슈	- 서버는 무조건 64비트 사용해야함
			- 32비트는 최대 4GB의 메모리 밖에 쓸 수 없다
			- 64비트는 16ExaByte의 메모리가 가능 (테라, 헥사보다큼)
		- 프로그래밍시 int type과 Pointer type을 주의 해야함 (32비트, 64비트에 pointer의 크기가 다름)

Multi-processor	- SMP <-> MASTER (슈퍼컴퓨터) / SLAVE (GPU)
		- 게임서버는 전부 SMP다.

Multi-core	- CPU 성능향상 제한을 극복하기 위해
		- 프로그래밍을 아예 새로 짜야함

멀티프로세서와 멀티코어의 차이점 	- SW적으로는 차이 X
			- HW적으로는 메모리 접근시 성능 차이가 존재 
				- CPU 갯수 만큼 메모리 대역폭 증가
				- NUMA 문제 - 아직까지는 잘 고려하지 않음


CPU 발전		- 클럭속도 증가 (~2000s)
			- 물리법칙 한계에 부딪침 : 발열
		- Clock당 수행되는 명령어의 개수 증가
			- 아키텍쳐의 개선
			- 성능향상이 크지않음
		- Core 개수 증가 (2005s~)
			- 프로그램 작성 방식이 바뀌어야 함
			- 현재 64-Core까지
		- PipeLine의 고도화에 따른 주의
			- 파이프 라인을 리셋시키면 손해가 큼
			- 리셋의 원인
				- 시스템 콜
				- 분기 예측 오류
				- Interrupt, Exception
			- Stall의 원인 : Cache read miss
			- 대책 - 시스템 콜, if, switch을 될 수 있으면 자제
  		- Cache : 프로그램 실행 속도에 가장 큰 영향을 미치는 요소
			: Cache가 큰 CPU일 수록 속도가 빠르다.
		


Multi Processor Programming 
	- 멀티 쓰레드 프로그래밍
	- 잘하면 성능향상되지만 못하면 성능 하락된다.
	- Cache Thrashing에 주의 하라
		- cache는 line단위로 움직임 (32비트), A B가 같은 line에 있을때 쓰레드1이 A값변화 쓰레드2가 B값을 변화할때 line단위로 가져오기 때문에 에러발생

Memory 		- 일반적인 Desktop용 메모리가 아니라 Error 수정기능이 있는 특수 메모리 사용 (비싸다)
			- Desktop 메모리는 하루에 1비트꼴로 오류가 나지만 티 안남 (방사능 원인) -> 대부분이 그래픽이기 때문에 점색깔이 변했다 원상복구 되는 수준
			- 하지만 서버, 은행은 1비트에 큰 오류가 발생할 수 있음 (ex) 0골드에서 10억 골드
		- 대역폭이 크지만 반응속도 느림

NetWork		- 10M -> ... -> 10G까지 발전
		- 서버간의 연결을 위해 한 서버에 여러 개의 네트워크 카드 꽂아 사용


서버 운영체제 종류	- Unix (Linux)
			- 가격이 저렴함
			- 유지 보수 어려움 ( 쓰는 사람이 적음, 전문가 필요 )
			- 차후 서버에 이용
		- Windows
			- Windows 2016, Windows 2019, Windows 2022 ( 서버용 윈도우가 있음, 존내 비쌈 ) 
			- 비싸다
			- 유지 보수 관리가 비교적 쉬움 ( 배우기 쉽다, 신경 쓸 것이 적다)

프로그램 치적화	- 필요한 일만 하기
			- new/delete 
		- 좋은 알고리즘 사용
			ex) map X, unordered_map을 사용 -> 자동정렬이 필요할 경우만 map
			- map이 unordered_map보다 성능 많이 사용
		- 메모리 복사 줄이기
			- call by Value, call by reference

		- HW 영향 고려
			- 파이프라인
		- 다섯번째 멀티쓰레드 프로그래밍






---------------- 네트워크 --------------------

패킷 		- 인터넷 표준에서의 패킷
			- 데이터의 단위

WSASocket은 windowsocket api임, C언어라 class불가

WSABUF buf[3]

----------------------------------------------
----------- I/O모델 ---------------------------

Non-blocking I/O
	- 단점 많은 recv 실패
	- cpu 낭비

Socket Thread
	- 1:1 게임서버가 여러개 있는 것과 비슷
	- 구현 쉬움
	- 잘 돌아감
	- 과도한 thread 개수로 인한 운영체제 Overhead
		- thread 오버헤드 : 컨텍스트 스위치, Stack 메모리

Coroutine을 사옹한 처리
	- 프로그래밍 방법은 thread-IO와 동일
	- Coroutine API에서 오버헤드 전부 해결
	문제	- C++20에 coroutine이 들어갔는데 아직 초기단계
		- C++23에 제대로 구현예정

Select
	- Unix시절 부터 내려온 고전적인 I/O 모델
	단점	- socket 개수의 한계 존재 // unix : 64, linux : 1024
		- socket의 개수가 많아질수록 성능 저하
	- 이전엔 사용했지만, 이젠 사용 안함

WSAAsyncSelect
	- 소켓 이벤트를 특정 윈도우의 메시지로 받는다.
	- Client는 Non-blocking I/O로 충분하나, 이걸로 구현 가능
	- Client에서만 쓸 수 있다.

WSAEventSelect
	- Window 가 없음
	- socket과 event의 array를 만들어서 
	- 윈도우 메시지 큐를 사용 -> 성능 느림 WSAWaitForMultipleEvents() 의 리턴값으로 부터 socket 추출
	- 소켓의 개수 64개 제한
	WSAEVENT 
		- 운영체제가 관리하는 플랙
		- 세마포어나 컨디션 변수와 비슷
		- Event가 발생했음을 알리는 용도

Overlapped I/O 모델
	- Windows에서 추가된 고성능 I/O 모델
	- 대용량 고성능 네트워크 서버에 필수
	- IOCP도 Overlapped I/O 사용
	- I/O요청 -> I/O 종료 확인
	- I/O요청 후 기다리지 않고 다른 일을 할 수 있다.
	- 여러개의 I/O 요청을 동시에 할 수 있다.

Overlapped I/O의
Event vs Callback

Overlapped I/O callback 모델	
	- 프로그램이 운영체제를 호출하고 대기중일 때, 운영체제에서 실행을 요청한다.
		- 운영체제를 호출하는 프로그램에서 호출에 대한 응답인지, callback실행 요청인지 판단해야 한다.
		- 모든 운영체제 호출이 Callback 검사하지 않는다.
	- Callback을 사용한 프로그램의 구조
		- 할 일 있으면 하고 없으면, SleepEx 호출

-------------IOCP----------------

서버에서 IOCP의 객체 생성은 하나로 충분

WSASend, WSARecv 뿐만아니라 Accept도 비동기(IOCP)로 작동해야함

클라에서 A,B,C,D 페킷을 보냈는데 A,B는 완료했고 C는 반 짤려서 왔을때 C의 크기를 알고 패킷 재조립해야함

패킷 재조립 코드는 졸작, 텀프에 쓰지마라
	- 표절 의혹에 휘말릴 수 있음
	- 직접 만들어라 ㅇㅇ
	- 샘플 코드 조심

AcceptEx에서는 lpob 를받는데 이게 3개 데이터를 한번에 처리한다.
	실습할때 안쓰지만 length에 0 0 0 넣으면 안됨
	-Clientaddr
		- 클라 주소
	-Serveraddr
		- 서버 주소
	-Recv데이터
		- 뒤늦게 Accept가 되었다면 Recv데이터까지 받음

---------------MultiThread--------------------

같은 프로세스와 모든 쓰레드는 DATA와 HEAP을
STACK만 쓰레드마다 가지고 있음
	-STACK엔 뭐가 있냐 local 변수, 지역 변수 -> 쓰레드가 끝나면 STACK영역은 지워짐





성능 -> 멀티 쓰레드 but (Data Race) -> lock을 걸면 더 느려짐
Live with DataRace
	-> compiler (volatile)
	-> CPU	    (atomic_thread_force)
	-> Cache    (pointer 주의)
	-> ABA	    (주소 재사용 문제)

















------------------------------------------